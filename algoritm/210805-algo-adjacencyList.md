# 210805-algo-adjacencyList.md

## 인접리스트\*\*\*

노드별로 인접한 노드들을 연결한다.

무방향 인접리스트 : graph[a].push(b); graph[b].push(a);

방향 인접리스트 : graph[a].push(b);

가중치 인접리스트 : graph[a].push([b,c];

### 코드 구현

방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프로그램(n, edges) 만들기
입력값 예시 : 5, [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]]
출력값 예시 : 6

1. **그래프를 배열로 만들고, ch 배열을 0값으로 세팅해준다.**

   - graph 배열 : 정점의 수+1만큼, 각각의 요소마다 빈 배열을 생성한다.
     - [노드1] : [노드1이 향하는 노드2(, 가중치)], [노드1이 향하는 노드3 (,가중치)...]
   - ch 배열 [정점의 수+1] 갔던 곳인지 체크

   ```jsx
   let graph = Array.from(Array(n + 1), () => Array());
   let ch = Array.from({ length: n + 1 }, () => 0);

   for (let [a, b] of edges) {
     //방향 그래프
     graph[a].push(b); //인접리스트 만드는 중
   }
   ```

2. **DFS 함수를 만든다 - v에서 갈 수 있는 모든 경로 찾기**

   ```jsx
   function DFS(v) {
     //v값에 연결된 인접 노드를 탐색한다.
     if (v === n) {
       //v = 도달!
       //console.log(path); //완성된 패스를 확인하고 싶다면 이용하기.
       answer++; //완성된 한 경로에서 실행하고싶은 동작 해주기
     } else {
       // v = 도달 안함!
       for (let nv of graph[v]) {
         //graph에서 v에서 갈 수 있는 모든 인접 노드 꺼내기
         if (ch[nv] === 0) {
           // 아직 가보지 않은 곳이라면
           ch[nv] = 1;
           //path.push(nv);
           DFS(nv); //인접 노드의 인접노드 탐색
           ch[nv] = 0; //다녀와서 다시 지우기!
           //path.pop();
         }
       }
     }
   }
   ```

3. **출발하는 값으로 DFS 함수를 호출한다.**

   ```jsx
   //path.push(1);
   ch[1] = 1;
   DFS(1);
   ```
