### 다이나믹 함수

다이나믹 함수는 속성은 유지하되, 아주 작은 단위로 문제를 쪼개어 그것부터 해결해나간다. 이 쪼갠 값을 넣는 테이블의 정의를 잘 하는것이 키 포인트!

점화식 : 앞에서 해결한 작은 조각을 기억해놓고, 뒤에서 그것들을 계속 이용해서 사용한다.

예) 피보나치 **f(n) = f(n-2) + f(n-1)**

**09-01. 문제로 다이나믹 함수가 어떤 것인지 살펴보자. -Bottom up**

**Q.** 계단을 1번 혹은 두번까지 한번에 오를 수 있다고 할 때, 마지막 계단까지 오를 수 있는 경우의 수는?

1. **테이블의 내용에 대한 정의 내리기**

   dy[i] : i 번 계단까지 오르는 방법의 수

2. **직관적으로 알 수 있는 작은 단위로 초기화**

   1번 계단까지 경우의 수: 1, 2번 계단까지 경우의 수: 2

3. **이 단위를 어떻게 이용할 것인가**

   3번 계단 : 1번 경우의 수 + 2번 경우의 수

   4번 계단 : 2번 경우의 수 + 3번 경우의 수

   ...

   n번 계단 : n-2번 경우의 수 + n-1번 경우의 수

**09-03. 최대부분 증가수열**

**Q.** N개의 자연수로 이루어진 수열이 주어졌을 때, 최대 부분 증가 수열을 구하여라
입력 예시 : [5,3,7,8,6,2,9,4] 출력 예시 : 4

1. 테이블의 내용 정의

   dy[i] : i번째 항이 마지막 항이 되는 최대 부분 증가수열의 길이

2. 직관적으로 알 수 있는 작은 단위로 초기화

   dy[0] : 1, dy[1]: 1, dy[2]:2, ...

3. 어떻게 이용되는가

   dy[n] : d[n] 보다 이전 값들 중 작은 값의 최대값+1

```jsx
function solution(nums, n) {
  let answer = 0;
  let ansArr = [];
  let dy = Array.from({ length: nums.length }, () => 0);
  dy[0] = 1;
  for (let i = 1; i < nums.length; i++) {
    let max = 0;
    for (let j = i - 1; j >= 0; j--) {
      //값이 더 적은 항 중에서 경우의 수가 다양할 수 있다.
      //따라서 다 돌면서 최대값을 max 변수에 넣어줘야 한다.
      if (nums[j] < nums[i] && dy[j] > max) {
        max = dy[j];
      }
    }
    dy[i] = max + 1;
  }
  console.log(dy);

  for (let x of dy) {
    answer = Math.max(x, answer);
  }
  return answer;
}

console.log(solution([5, 3, 7, 8, 6, 2, 9, 4]));
```
